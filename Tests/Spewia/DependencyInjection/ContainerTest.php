<?php
namespace Tests\Spewia\DependencyInjection;

use Spewia\DependencyInjection\Container;

/**
 * Test class for Container.
 * Generated by PHPUnit on 2012-03-23 at 11:39:33.
 *
 */
class ContainerTest extends \PHPUnit_Framework_TestCase
{
    const   FOO_CLASS       = '\Tests\Spewia\DependencyInjection\Foo',
            BAR_CLASS       = '\Tests\Spewia\DependencyInjection\Bar',
            FOOBAR_CLASS    = '\Tests\Spewia\DependencyInjection\FooBar',
            FACTORY_CLASS   = '\Tests\Spewia\DependencyInjection\Factory';
    /**
     * @var Container
     */
    protected $object;

    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    protected function setUp()
    {
        $this->object = new Container(array(
            'foo' => array(
                'class' => self::FOO_CLASS
            ),
            'bar' => array(
                'class' => self::BAR_CLASS,
                'constructor_parameters' => array(
                    array(
                        'type'  => 'service',
                        'id'    => 'foo'
                    ),
                    array(
                        'type'  => 'constant',
                        'value' => 'string'
                    )
                )
            ),
            'foobar' => array(
                'class' => self::FOOBAR_CLASS,
                'constructor_parameters' => array(
                    array(
                        'type'  => 'service',
                        'id'    => 'bar2'
                    )
                )
            ),
            'bar2' => array(
                'class' => self::BAR_CLASS,
                'constructor_parameters' => array(
                    array(
                        'type'  => 'service',
                        'id'    => 'foobar'
                    ),
                    array(
                        'type'  => 'constant',
                        'value' => 'string'
                    )
                )
            ),
            'foobar2' => array(
                'class' => self::FOOBAR_CLASS,
                'constructor_parameters' => array(
                    array(
                        'type'  => 'service',
                        'id'    => 'bar'
                    )
                ),
                'configuration_calls' => array(
                    'setFoo'    => array(
                        array(
                            'type'  => 'service',
                            'id'    => 'foobar2'
                        )
                    )
                )
            ),
            'foobar3' => array(
                'class' => self::FOOBAR_CLASS,
                'constructor_parameters' => array(
                    array(
                        'type'  => 'service',
                        'id'    => 'bar'
                    )
                ),
                'configuration_calls' => array(
                    'setFoo' => array(
                        array(
                            'type'  => 'service',
                            'id'    => 'foo2'
                        )
                    )
                )
            ),
            'foo2' => array(
                'class' => self::FOO_CLASS,
                'configuration_calls' => array(
                    'setFoo' => array(
                        array(
                            'type'  => 'service',
                            'id'    => 'foo'
                        )
                    )
                )
            ),
            'factory_foo' => array(
                'class' => self::FOO_CLASS,
                'factory' => array(
                    'class'     => self::FACTORY_CLASS,
                    'method'    => 'buildStatic',
                    'params'    => array(
                        array(
                            'type'  => 'service',
                            'id'    => 'foo'
                        )
                    )
                )
            ),
            'factory_service' => array(
                'class' => self::FACTORY_CLASS
            ),
            'factory_bar' => array(
                'class' => self::BAR_CLASS,
                'factory' => array(
                    'service'   => 'factory_service',
                    'method'    => 'buildDynamic',
                    'params'    => array(
                        array(
                            'type'  => 'service',
                            'id'    => 'foo'
                        )
                    )
                )
            )
        ));
    }

    public function testGetSelf()
    {
        $return = $this->object->get('self');

        $this->assertInstanceOf('\Spewia\DependencyInjection\Container', $return,
            'The return should be of class "Container".');

        $this->assertSame($this->object, $return,
            'The return of getting the "self" key should always be the container.');
    }

    public function testGetWithNoDependencies()
    {
        $return = $this->object->get('foo');

        $this->assertInstanceOf(
            self::FOO_CLASS, $return,
            'The key "foo" expected an instance of type "Foo".');
    }

    public function testMultipleGetCalls()
    {
        $first = $this->object->get('foo');
        $second = $this->object->get('foo');

        $this->assertSame($first, $second,
            'Two calls on the same key should return the same object.');
    }

    public function testGetWithDependencies()
    {
        $return = $this->object->get('bar');

        $this->assertInstanceOf(self::BAR_CLASS, $return,
            'The key "bar" expected an instance of type "Bar".');

        $foo = $this->object->get('foo');

        $this->assertSame($foo, $return->getFoo(),
            'The "foo" key and the embedded "foo" element should be the same.');

        $this->assertEquals('string', $return->getString(),
            'The "string", element to be embedded should have the value "string".');
    }

    /**
     * @runInSeparateProcess
     * @expectedException \Spewia\DependencyInjection\Exception\CircularDependencyException
     */
    public function testGetWithCircularDependency()
    {
        $this->object->get('foobar');
    }

    /**
     * @expectedException \Spewia\DependencyInjection\Exception\ServiceNotFoundException
     */
    public function testGetNonExistingService()
    {
        $this->object->get('unexisting_service');
    }

    public function testGetWithSetterDependencies()
    {
        $return = $this->object->get('foobar2');

        $this->assertSame($return, $return->getFoo(),
            'The two objects must be the same.');
    }

    public function testGetWithSetterDependenciesWichHaveSetterDependencies()
    {
        $return = $this->object->get('foobar3');

        $inner_dependecy = $return->getFoo()->getFoo();

        $this->assertInstanceOf(self::FOO_CLASS, $inner_dependecy,
            'The Foo object should contain a foo object itself.');

        $this->assertSame($this->object->get('foo'), $inner_dependecy,
            ' The inner dependency should be the same than the object fetched from calling $container->get("foo").');
    }

    public function testGetFromClassWithStaticFactory()
    {
        $foo = $this->object->get('factory_foo');

        $this->assertInstanceOf(self::FOO_CLASS, $foo,
            'The foo obtained from the factory should be of class Foo.');

        $this->assertSame($this->object->get('foo'), $foo->getFoo(),
            'The Foo object from the factory should have been injected the "foo" element.');
    }

    public function testGetFromClassWithInstantiatedFactory()
    {
        $bar = $this->object->get('factory_bar');

        $this->assertInstanceOf(self::BAR_CLASS, $bar,
            'The object obtained from the factory should be of class Bar.');

        $this->assertSame($this->object->get('foo'), $bar->getFoo(),
            'The Bar object from the factory should have been injected the "foo" element.');

        $this->assertSame('FROM_FACTORY', $bar->getString(),
            'The bar object should contain the string wich is defined in the Factory constructor.');
    }

    public function testAddServiceConfigurations()
    {
        $this->object->addServiceConfigurations(array(
            'added_foo' => array(
                'class' => self::FOO_CLASS
            )
        ));

        $foo = $this->object->get('added_foo');

        $this->assertInstanceOf(self::FOO_CLASS, $foo,
            'The new definition should be used and return an instance of the class "Foo".');
    }

    public function testAddServiceConfigurationsOverwrites()
    {
        $this->object->get('foo2');

        $this->object->addServiceConfigurations(array(
            'foo2' => array(
                'class' => self::BAR_CLASS,
                'constructor_parameters' => array(
                    array(
                        'type'  => 'service',
                        'id'    => 'foo'
                    ),
                    array(
                        'type'  => 'constant',
                        'value' => 'string'
                    )
                )
            )
        ));

        $bar = $this->object->get('foo2');

        $this->assertInstanceOf(self::BAR_CLASS, $bar,
            'The element whose configuration has changed should be of class "Bar". If there was an instance of the '
            . 'previous configuration, it shouldn\'t have been used.');
    }
}

class Factory
{
    protected $factory_string = null;

    public function __construct()
    {
        $this->factory_string = 'FROM_FACTORY';
    }

    public static function buildStatic(Foo $foo = null)
    {
        $object = new Foo();



        if($foo) {
            $object->setFoo($foo);
        }

        return $object;
    }

    public function buildDynamic(Foo $foo)
    {
        return new Bar($foo, $this->factory_string);
    }
}

class Foo
{
    protected $foo;

    public function setFoo(Foo $foo)
    {
        $this->foo = $foo;
    }

    public function getFoo()
    {
        return $this->foo;
    }
}

class Bar
{
    protected $foo;
    protected $string;

    public function __construct(Foo $foo, $string)
    {
        $this->foo = $foo;
        $this->string = $string;
    }

    public function getFoo()
    {
        return $this->foo;
    }

    public function getString()
    {
        return $this->string;
    }
}

class FooBar extends Foo
{
    protected $bar;
    protected $foo;

    public function __construct(Bar $bar)
    {
        $this->bar = $bar;
    }

    public function setFoo(Foo $foo)
    {
        $this->foo = $foo;
    }

    public function getFoo()
    {
        return $this->foo;
    }
}